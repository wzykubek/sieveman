package parsers

import (
	"errors"
	"regexp"

	"go.wzykubek.xyz/sieveman/pkg/proto"
)

func ParseResponse(line string) (proto.Response, error) {
	// This regular expression was generated by Copilot.
	// It SHOULD parse a string containing three parts with the known pattern:
	// 		P1 (P2 ...) "P3 ..."
	//
	// where:
	//		P1		- is mandatory and does not contain whitespace
	//		(P2)	- is optional, contains parentheses, and can contain whitespace inside
	//		"P3"	- is optional, contains quotation marks, and can contain whitespace inside
	//
	// When P2 or "P3" is not present, it MUST return an empty string for those parts.
	re := regexp.MustCompile(`^(\S+)\s*(\([^)]*\))?\s*("[^"]*")?$`)
	matches := re.FindStringSubmatch(line)
	if len(matches) == 0 {
		return nil, errors.New("regex error")
	}

	resp := matches[1]
	code, err := ParseResponseCode(matches[2])
	if err != nil {
		return nil, err
	}
	msg := matches[3]

	switch resp {
	case "OK":
		return proto.ResponseOK{ResponseCode: code, Msg: msg}, nil
	case "NO":
		return proto.ResponseNO{ResponseCode: code, Msg: msg}, nil
	case "BYE":
		return proto.ResponseBYE{ResponseCode: code, Msg: msg}, nil
	default:
		return nil, nil
	}
}

func ParseResponseCode(codeStr string) (proto.ResponseCode, error) {
	if codeStr == "" {
		return nil, nil
	}

	// This regular expression was generated by Copilot.
	// It SHOULD parse a string containing two parts with the known pattern in parentheses:
	// 		(P1 "P2 ...")
	//
	// where:
	//		P1		- is mandatory and does not contain whitespace
	//		"P2"	- is optional, contains quotation marks, and can contain whitespace inside
	//
	// When "P2" is not present, it MUST return an empty string for that part.
	// It also removes the surrounding parentheses.
	re := regexp.MustCompile(`^\((\S+)\s*("[^"]*")?\)$`)
	matches := re.FindStringSubmatch(codeStr)

	code := matches[1]
	msg := matches[2]

	switch code {
	case "TAG":
		return proto.Tag{Msg: msg, ChildCode: nil}, nil
	default:
		return nil, nil
	}
}

func ParseMessage(line string) (proto.Message, error) {
	// This regular expression was generated by Copilot.
	// It SHOULD parse string containing three parts with known pattern:
	// 		"P1 ..." "P2 ..."
	//
	// where:
	// 		"P1"	- is required
	//		"P2" 	- is optional
	//
	// When there is not "P2" it MUST return empty string.
	re := regexp.MustCompile(`^("[^"]*")(?:\s*("[^"]*"))?$`)
	matches := re.FindStringSubmatch(line)
	if len(matches) == 0 {
		return proto.Message{}, errors.New("regex error")
	}

	return proto.Message{Key: matches[1], Value: matches[2]}, nil
}
