// TODO: Refactoring of whole reading mechanism is needed.
// Responses should not have message included, only OK, NO or BYE.
// All messages should be parsed and returned as separate fields.
// Handling of both response patterns should be implemented.
// Response codes is subject to change.
package client

import (
	"regexp"
	"strings"

	"go.wzykubek.xyz/sieveman/pkg/proto"
)

func parseResponse(respStr string) proto.Response {
	if respStr == "" {
		return nil
	}

	// This regular expression was generated by Copilot.
	// It SHOULD parse a string containing three parts with the known pattern:
	// 		P1 (P2 ...) "P3 ..."
	//
	// where:
	//		P1		- is mandatory and does not contain whitespace
	//		(P2)	- is optional, contains parentheses, and can contain whitespace inside
	//		"P3"	- is optional, contains quotation marks, and can contain whitespace inside
	//
	// When P2 or "P3" is not present, it MUST return an empty string for those parts.
	re := regexp.MustCompile(`^(\S+)\s*(\([^)]*\))?\s*("[^"]*")?$`)
	matches := re.FindStringSubmatch(strings.TrimSpace(respStr))

	var resp, msg string
	var code proto.ResponseCode

	if len(matches) <= 2 {
		// Edge case: `P1 (P2) {bytes}\nP3`
		if strings.HasPrefix(respStr, "NO ") || strings.HasPrefix(respStr, "BYE ") || strings.HasPrefix(respStr, "OK ") {
			parts := strings.Split(respStr, " ")
			resp = parts[0]
			// TODO: It will break if there will be response code.
			msg = strings.TrimSpace(parts[1]) // Temporary
		} else {
			return nil
		}
	} else {
		resp = matches[1]
		code = parseResponseCode(matches[2])
		msg = strings.Trim(matches[3], "\"")
	}

	switch resp {
	case "OK":
		return proto.Ok{ResponseCode: code, Msg: msg}
	case "NO":
		return proto.No{ResponseCode: code, Msg: msg}
	case "BYE":
		return proto.Bye{ResponseCode: code, Msg: msg}
	default:
		return nil
	}
}

func parseResponseCode(codeStr string) proto.ResponseCode {
	if codeStr == "" {
		return nil
	}

	// This regular expression was generated by Copilot.
	// It SHOULD parse a string containing two parts with the known pattern in parentheses:
	// 		(P1 "P2 ...")
	//
	// where:
	//		P1		- is mandatory and does not contain whitespace
	//		"P2"	- is optional, contains quotation marks, and can contain whitespace inside
	//
	// When "P2" is not present, it MUST return an empty string for that part.
	// It also removes the surrounding parentheses.
	re := regexp.MustCompile(`^\((\S+)\s*("[^"]*")?\)$`)
	matches := re.FindStringSubmatch(codeStr)

	code := strings.Split(matches[1], "/")
	msg := strings.Trim(matches[2], "\"")

	// TODO: Make it simpler, this is overengineered
	switch code[0] {
	case "TAG":
		return proto.Tag{Msg: msg, ChildCode: nil}
	case "NONEXISTENT":
		return proto.NonExistent{Msg: "", ChildCode: nil}
	case "QUOTA":
		switch code[1] {
		case "MAXSIZE":
			return proto.Quota{Msg: "", ChildCode: proto.MaxSize{Msg: msg, ChildCode: nil}}
		default:
			return proto.Quota{Msg: msg, ChildCode: nil}
		}
	default:
		return nil
	}
}

// ReadResponse is a low level method to read and parse response from server.
// It returns parsed response, slice of messages and error if any.
func (c *Client) ReadResponse() (_ proto.Response, messages []string, err error) {
	for {
		var line string
		line, err = c.Reader.ReadString('\n')
		if err != nil {
			return nil, messages, err
		}

		if resp := parseResponse(line); resp != nil {
			// Handle nested responses with 'P1 (P2) {bytes}\nP3' pattern
			if matched, _ := regexp.MatchString(`^\{.*\}$`, resp.Message()); matched {
				for {
					line, err := c.Reader.ReadString('\n')
					if err != nil {
						return nil, messages, err
					}
					line = strings.TrimSpace(line)
					if line == "" {
						break
					}
					messages = append(messages, line)
				}
			}
			return resp, messages, nil
		} else {
			messages = append(messages, line)
		}
	}
}
